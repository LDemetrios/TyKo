package org.ldemetrios.docgen.org.ldemetrios.tyko.docs

import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.extension
import kotlin.io.path.walk
import kotlin.math.abs

private const val AUTO_DOC_MARKER = "// AUTO-GENERATED DOCS. DO NOT EDIT."
private const val PARAM_DOC_INDENT = "    "
private val CLASS_DECLARATION = Regex(
    """^\s*(?:(?:public|private|protected|internal)\s+)?""" +
            """(?:(?:data|sealed|enum|open|abstract|final)\s+)*""" +
            """(class|interface|object)\b"""
)

fun scanLinks(root: Path): List<LinkComment> {
    return root.walk()
        .filter { Files.isRegularFile(it) && it.extension == "kt" }
        .flatMap { file ->
            Files.readAllLines(file)
                .asSequence()
                .withIndex()
                .mapNotNull { (index, line) ->
                    val trimmed = line.trimStart()
                    if (!trimmed.startsWith("//!")) return@mapNotNull null
                    val url = trimmed.removePrefix("//!").trim()
                    if (url.isEmpty()) return@mapNotNull null
                    LinkComment(
                        sourceFile = file,
                        lineNumber = index + 1,
                        url = url,
                    )
                }
        }
        .toList()
}

fun writeDocs(docs: List<ClassDoc>) {
    if (docs.isEmpty()) return
    val file = docs.first().source.sourceFile
    if (docs.any { it.source.sourceFile != file }) {
        throw IllegalArgumentException("All docs must target the same source file.")
    }
    if (!Files.exists(file)) {
        throw IllegalStateException("Source file does not exist: $file")
    }

    val lines = removeAutoGeneratedDoc(Files.readAllLines(file)).toMutableList()

    docs.sortedByDescending { it.source.lineNumber }.forEach { doc ->
        val classIndex = findClassDeclarationIndex(lines, doc.source)
            ?: throw IllegalStateException(
                "Class declaration not found after cleanup at $file:${doc.source.lineNumber}",
            )
        val classInsertionIndex = findInsertionIndex(lines, classIndex)

        val paramInsertionPoints = findParamInsertionPoints(
            lines,
            classIndex,
            doc.params.keys,
            file
        )

        paramInsertionPoints
            .toList()
            .sortedByDescending { it.second }
            .forEach { (paramName, index) ->
                val kdoc = doc.params[paramName]
                    ?: throw IllegalStateException("Missing KDoc for parameter: $paramName")
                lines.addAll(index, renderBlock(kdoc, doc.source.url, PARAM_DOC_INDENT))
            }

        lines.addAll(classInsertionIndex, renderBlock(doc.classDoc, doc.source.url))
    }

    Files.write(file, lines)
}

private fun findClassDeclarationIndex(lines: List<String>, source: LinkComment): Int? {
    val commentIndex = findLinkCommentIndex(lines, source)
    val startIndex = (commentIndex + 1).coerceIn(0, lines.size)
    return (startIndex until lines.size)
        .firstOrNull { CLASS_DECLARATION.containsMatchIn(lines[it]) }
}

private fun findLinkCommentIndex(lines: List<String>, source: LinkComment): Int {
    val candidates = lines.asSequence()
        .withIndex()
        .filter { (_, line) -> line.trimStart().startsWith("//!") }
        .filter { (_, line) ->
            val trimmed = line.trimStart()
            val url = trimmed.removePrefix("//!").trim()
            url == source.url
        }
        .map { it.index }
        .toList()

    if (candidates.isEmpty()) {
        throw IllegalStateException("Link comment not found: ${source.sourceFile}:${source.lineNumber}")
    }

    val expected = (source.lineNumber - 1).coerceIn(0, lines.size - 1)
    return candidates.minBy { abs(it - expected) }
}

private fun removeAutoGeneratedDoc(lines: List<String>): List<String> {
    val output = mutableListOf<String>()
    var skippingKdoc = false
    var i = 0

    while (i < lines.size) {
        val line = lines[i]
        if (skippingKdoc) {
            if (line.trimStart().startsWith("*/")) {
                skippingKdoc = false
            }
            i++
            continue
        }

        if (line.trimStart() == AUTO_DOC_MARKER) {
            i++
            while (i < lines.size && lines[i].isBlank()) {
                i++
            }
            if (i < lines.size && lines[i].trimStart().startsWith("/**")) {
                skippingKdoc = true
                i++
                continue
            }
            output.add(line)
            continue
        }

        output.add(line)
        i++
    }

    return output
}

private fun findInsertionIndex(lines: List<String>, classIndex: Int): Int {
    val annotationIndices = (classIndex - 1 downTo 0)
        .asSequence()
        .takeWhile { lines[it].isNotBlank() }
        .takeWhile { lines[it].trimStart().startsWith("@") }
        .toList()

    return annotationIndices.lastOrNull() ?: classIndex
}

private fun renderBlock(doc: KDocDocument, sourceUrl: String, indent: String = ""): List<String> {
    val kdoc = doc.render(sourceUrl)
    return buildList {
        add(indent + AUTO_DOC_MARKER)
        addAll(kdoc.split('\n').map { indent + it })
    }
}

private fun findParamInsertionPoints(
    lines: List<String>,
    classIndex: Int,
    params: Set<String>,
    file: Path
): Map<String, Int> {
    if (params.isEmpty()) return emptyMap()

    val paramRange = findParamListRange(lines, classIndex)
        ?: throw IllegalStateException(
            "Primary constructor parameter list not found near line ${classIndex + 1}",
        )
    // Ignore same-line constructor parameters in class declaration.
    // These tend to be compact wrappers where field-level generated docs are undesired.
    val paramLines = (paramRange.first..paramRange.last).filter { it != classIndex }

    return params.associateWith { name ->
        val lineIndex = findParamLineIndex(lines, paramLines, name)
            ?: return@associateWith null
//            throw IllegalArgumentException( <- for types it's actually okay
//                "Missing '$name' in ${file.fileName}",
//            )
        findParamInsertionIndex(lines, lineIndex, paramRange)
    }.filterValues { it != null } as Map<String, Int>
}

private fun findParamLineIndex(
    lines: List<String>,
    paramLines: List<Int>,
    name: String,
): Int? {
    val nameKebab = name.replace('\u00A0', ' ').trim()
    val namePattern = Regex("""(?<!@)\b${Regex.escape(nameKebab)}\b\s*:""")
    val backtickedPattern = Regex(
        """(?<!@)`${
            Regex.escape(nameKebab)
        }`\s*:"""
    )
    return paramLines.firstOrNull { index ->
        val line = lines[index]
        val paramNames = extractParamNames(line)
        paramNames.any { camelToKebab(it) == nameKebab } ||
                namePattern.containsMatchIn(line) ||
                backtickedPattern.containsMatchIn(line)
    }
}

private val CAMEL_BOUNDARY = Regex(
    listOf(
        "(?<=[a-z])(?=[A-Z0-9])",
        "(?<=[A-Z])(?=[A-Z][a-z])",
        "(?<=[0-9])(?=[A-Za-z])",
    ).joinToString("|")
)

private fun camelToKebab(str: String): String = str.trim('`').replace(CAMEL_BOUNDARY, "-").lowercase()

private fun extractParamNames(line: String): List<String> {
    val names = mutableListOf<String>()
    val valVarRegex = Regex("""(?:val|var)\s+(`[^`]+`|[A-Za-z_][A-Za-z0-9_]*)""")
    valVarRegex.findAll(line).forEach { match ->
        val raw = match.groupValues[1]
        names.add(raw.trim('`'))
    }
    if (names.isNotEmpty()) return names

    val bareRegex = Regex("""(?<!@)\b(`[^`]+`|[A-Za-z_][A-Za-z0-9_]*)\s*:""")
    bareRegex.findAll(line).forEach { match ->
        val candidate = match.groupValues[1].trim('`')
        if (candidate !in listOf("val", "var", "override")) {
            names.add(candidate)
        }
    }
    return names
}

private fun findParamListRange(lines: List<String>, classIndex: Int): IntRange? {
    val open = findTokenAfterIndex(lines, classIndex, '(') ?: return null
    var depth = 0
    var close: Int? = null
    var i = open.first
    var col = open.second
    while (i < lines.size && close == null) {
        val line = lines[i]
        var j = if (i == open.first) col else 0
        while (j < line.length) {
            when (line[j]) {
                '(' -> depth++
                ')' -> {
                    depth--
                    if (depth == 0) {
                        close = i
                        break
                    }
                }
            }
            j++
        }
        i++
    }
    return close?.let { open.first..it }
}

private fun findTokenAfterIndex(lines: List<String>, startIndex: Int, token: Char): Pair<Int, Int>? {
    return (startIndex until lines.size)
        .asSequence()
        .mapNotNull { lineIndex ->
            val col = lines[lineIndex].indexOf(token)
            if (col >= 0) lineIndex to col else null
        }
        .firstOrNull()
}

private fun findParamInsertionIndex(
    lines: List<String>,
    paramLineIndex: Int,
    paramRange: IntRange,
): Int {
    val annotationIndices = (paramLineIndex - 1 downTo paramRange.first)
        .asSequence()
        .takeWhile { lines[it].isNotBlank() }
        .takeWhile { line ->
            val trimmed = lines[line].trimStart()
            trimmed.startsWith("@") && !trimmed.contains(" val ") && !trimmed.contains(" var ")
        }
        .toList()

    if (annotationIndices.isEmpty()) return paramLineIndex

    // Avoid inserting docs above unrelated annotations when multiple params share a line.
    val earliestAnnotation = annotationIndices.last()
    val priorParamLine = (paramLineIndex - 1 downTo earliestAnnotation)
        .firstOrNull { extractParamNames(lines[it]).isNotEmpty() }

    return priorParamLine ?: earliestAnnotation
}
